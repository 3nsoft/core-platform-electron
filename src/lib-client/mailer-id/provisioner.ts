/*
 Copyright (C) 2015 - 2017 3NSoft Inc.
 
 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
 Foundation, either version 3 of the License, or (at your option) any later
 version.
 
 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 See the GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License along with
 this program. If not, see <http://www.gnu.org/licenses/>. */

import { makeException, NetClient, makeNetClient } from '../electron/net';
import { mailerIdInfoAt } from '../service-locator';
import { ServiceUser, ICalcDHSharedKey, LoginCompletion }
	from '../user-with-pkl-session';
import { SignedLoad, JsonKey, keyToJson, getKeyCert }
	from '../../lib-common/jwkeys';
import { deepEqual } from '../../lib-common/json-utils';
import { toCanonicalAddress } from '../../lib-common/canonical-address';
import * as mid from '../../lib-common/mid-sigs-NaCl-Ed';
import * as random from '../../lib-common/random-node';
import * as certProvApi from 
	'../../lib-common/service-api/mailer-id/provisioning';
import { parse as parseUrl } from 'url';

const DEFAULT_ASSERTION_VALIDITY = 20*60;

export interface ProvisioningCompletion {
	keyParams: any;
	serverPKey: Uint8Array;
	complete(dhsharedKeyCalc: ICalcDHSharedKey, certDuration: number,
		assertDuration?: number): Promise<mid.user.MailerIdSigner>;
}

/**
 * Certificate provisioner is an object that can do all MailerId's provisioning
 * requests.
 * Provisioning is done for given user id, and is performed at service location,
 * identified by a given uri.
 */
export class MailerIdProvisioner extends ServiceUser {
	
	private userCert: SignedLoad = (undefined as any);
	private provCert: SignedLoad = (undefined as any);
	private midDomain: string = (undefined as any);
	private rootCert: SignedLoad = (undefined as any);
	private entryURI: string;
	
	/**
	 * @param userId
	 * @param uri identifies place of MailerId service.
	 */
	constructor(userId: string, serviceUri: string) {
		super(userId, {
			login: '',
			logout: ''
		});
		if (!serviceUri) { throw new Error('Given bad MailerId service uri.'); }
		this.serviceURI = serviceUri;
		this.entryURI = this.serviceURI;
		Object.seal(this);
	}

	private async setUrlAndDomain(): Promise<void> {
		const info = await mailerIdInfoAt(this.net, this.entryURI);
		this.midDomain = parseUrl(this.serviceURI).hostname!;
		this.serviceURI = info.provisioning;
		this.rootCert = info.currentCert;
	}
	
	/**
	 * @param pkey is a public key, that needs to be certified.
	 * @param duration is a desired duration of certificate's validity.
	 * Server may provide shorter duration, if asked duration is too long
	 * for its security policy.
	 * @return a promise, resolvable to a string with certificate, generated by
	 * the MailerId server.
	 */
	private async getCertificates(pkey: JsonKey, duration: number):
			Promise<void> {
		const plainReqData: certProvApi.certify.Request = {
			pkey: pkey,
			duration: duration
		};
		const rep = await this.net.doBinaryRequest<Uint8Array>({
			url: this.serviceURI + certProvApi.certify.URL_END,
			method: 'POST',
			sessionId: this.sessionId,
			responseType: 'arraybuffer'
		}, this.encryptor.packJSON(plainReqData));
		try {
			if (rep.status === certProvApi.certify.SC.ok) {
				let certs: certProvApi.certify.Reply;
				try {
					certs = this.encryptor.openJSON(rep.data);
				} catch (err) {
					throw makeException(rep,
						'Malformed reply: '+err.message);
				}
				if (!certs.userCert || !certs.provCert) {
					throw makeException(rep,
						'Malformed reply: Certificates are missing.');
				}
				const pkeyAndId = mid.relyingParty.verifyChainAndGetUserKey(
					{ user: certs.userCert, prov: certs.provCert,
						root: this.rootCert }, this.midDomain,
					getKeyCert(certs.userCert).issuedAt+1);
				if (pkeyAndId.address !== toCanonicalAddress(this.userId)) {
					throw makeException(rep,
						'Malformed reply: Certificate is for a wrong address.');
				}
				const keyInCert = keyToJson(pkeyAndId.pkey);
				if (!deepEqual(keyInCert, pkey)) {
					throw makeException(rep,
						'Malformed reply: Certificate is for a wrong key.');
				}
				this.userCert = certs.userCert;
				this.provCert = certs.provCert;
			} else {
				throw makeException(rep, 'Unexpected status');
			}
		} finally {
			this.sessionId = (undefined as any);
			this.encryptor.destroy();
			this.encryptor = (undefined as any);
		}
	}
	
	/**
	 * This method hides super from await, till ES7 comes with native support
	 * for await.
	 */
	private super_login(keyId: string|undefined): Promise<LoginCompletion> {
		return super.login(keyId);
	}
	
	/**
	 * This method starts certificate provisioning process, by starting login,
	 * producing a function that will accept shared key calculator for login,
	 * and certification parameter(s), needed to complete certification itself.
	 * This metho returns a promise, resolvable to a function that will complete
	 * login and certification process.
	 * @param keyId is a key id of a key that should be used in the login.
	 * Undefined value means that a default key should be used.
	 */
	async provisionSigner(keyId: string|undefined):
			Promise<ProvisioningCompletion> {
		const pair = mid.user.generateSigningKeyPair(random.bytesSync);
		await this.setUrlAndDomain();
		const login = await this.super_login(keyId);
		const completion = async (
				dhsharedKeyCalc: ICalcDHSharedKey,
				certDuration: number,
				assertDuration = DEFAULT_ASSERTION_VALIDITY) => {
			await login.complete(dhsharedKeyCalc);
			await this.getCertificates(pair.pkey, certDuration);
			return mid.user.makeMailerIdSigner(
				pair.skey, this.userCert, this.provCert, assertDuration);
		};
		return {
			keyParams: login.keyParams,
			serverPKey: login.serverPKey,
			complete: completion
		};
	}
	
	login(): Promise<LoginCompletion> {
		throw Error("This function is not used in provisioner");
	}
	logout(): Promise<void> {
		throw Error("This function is not used in provisioner");
	}
	
}

Object.freeze(exports);